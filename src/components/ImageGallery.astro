---
import { getTranslation } from '../i18n/translations';

interface Props {
  images: string[];
  alt: string;
}

const { images, alt } = Astro.props;
const imageLabel = getTranslation(Astro.currentLocale, 'gallery.image');

// サイド画像の枚数と列数を決定
const getRightSideCount = (totalImages: number): number => {
  if (totalImages <= 2) return 0;
  // メイン画像以外の枚数を2で割って，右側の枚数を計算 (奇数の場合は右側が多い)
  return Math.min(6, Math.ceil((totalImages - 1) / 2));
};

const getLeftSideCount = (totalImages: number): number => {
  if (totalImages <= 2) return 0;
  // 左側の枚数 (奇数の場合は左側が少ない)
  return Math.min(6, Math.floor((totalImages - 1) / 2));
};

const rightSideCount = getRightSideCount(images.length);
const leftSideCount = getLeftSideCount(images.length);
---

<div class="image-gallery">
  <div class="gallery-container">
    {
      leftSideCount > 0 && (
        <div class="side-images left-side" style={`--columns: ${Math.ceil(leftSideCount / 2)}`}>
          {Array.from({ length: leftSideCount }).map((_, i) => (
            <img
              id={`left-image-${i}`}
              src={images[1 + rightSideCount + i]}
              alt={alt}
              class="side-img"
              data-side-index={i}
            />
          ))}
        </div>
      )
    }

    <div class="main-image-container">
      <img id="main-image" src={images[0]} alt={alt} class="main-image" />
    </div>

    {
      rightSideCount > 0 && (
        <div class="side-images right-side" style={`--columns: ${Math.ceil(rightSideCount / 2)}`}>
          {Array.from({ length: rightSideCount }).map((_, i) => (
            <img
              id={`right-image-${i}`}
              src={images[1 + i]}
              alt={alt}
              class="side-img"
              data-side-index={i}
            />
          ))}
        </div>
      )
    }
  </div>

  {
    images.length > 1 && (
      <div class="dots-nav">
        {images.map((_, index) => (
          <button
            type="button"
            class={`dot ${index === 0 ? 'active' : ''}`}
            data-index={index}
            aria-label={`${imageLabel} ${index + 1}`}
          />
        ))}
      </div>
    )
  }
</div>

<script is:inline define:vars={{ images }}>
  let currentIndex = 0;
  const mainImage = document.getElementById('main-image');
  const leftSideImages = document.querySelectorAll('.left-side .side-img');
  const rightSideImages = document.querySelectorAll('.right-side .side-img');
  const dots = document.querySelectorAll('.dot');

  function updateImage(index) {
    currentIndex = index;
    if (mainImage) {
      mainImage.src = images[index];
    }

    // 右サイド画像の更新 (現在のインデックスから見て次の画像)
    rightSideImages.forEach((img, i) => {
      const targetIndex = (index + 1 + i) % images.length;
      img.src = images[targetIndex];
    });

    // 左サイド画像の更新 (右サイドの後の画像)
    leftSideImages.forEach((img, i) => {
      const targetIndex = (index + 1 + rightSideImages.length + i) % images.length;
      img.src = images[targetIndex];
    });

    // ドットの更新
    dots.forEach((dot, i) => {
      dot.classList.toggle('active', i === index);
    });

    // アクティブなドットをスクロール表示
    const activeDot = dots[index];
    if (activeDot) {
      // scrollIntoView を使って確実に表示
      requestAnimationFrame(() => {
        activeDot.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest',
          inline: 'center',
        });
      });
    }
  }

  // ドットクリック
  dots.forEach((dot) => {
    dot.addEventListener('click', (e) => {
      const index = parseInt(e.currentTarget.dataset.index);
      updateImage(index);
    });
  });

  // 右サイド画像クリック
  rightSideImages.forEach((img, i) => {
    img.addEventListener('click', () => {
      const newIndex = (currentIndex + 1 + i) % images.length;
      updateImage(newIndex);
    });
  });

  // 左サイド画像クリック
  leftSideImages.forEach((img, i) => {
    img.addEventListener('click', () => {
      const newIndex = (currentIndex + 1 + rightSideImages.length + i) % images.length;
      updateImage(newIndex);
    });
  });

  // スワイプ・ドラッグ対応
  let startX = 0;
  let currentX = 0;
  let isDragging = false;
  let hasMoved = false;
  const container = mainImage?.parentElement;
  const swipeThreshold = 60; // 切り替えに必要な移動距離
  const minMoveDistance = 5; // クリックとドラッグを区別する最小距離

  if (mainImage && container) {
    // タッチイベント (スマホ)
    mainImage.addEventListener(
      'touchstart',
      (e) => {
        startX = e.changedTouches[0].clientX;
        currentX = startX;
        hasMoved = false;
      },
      { passive: true }
    );

    mainImage.addEventListener(
      'touchmove',
      (e) => {
        if (!startX) return;
        currentX = e.changedTouches[0].clientX;
        const diff = currentX - startX;

        if (Math.abs(diff) > minMoveDistance) {
          hasMoved = true;
        }

        // ドラッグ中の視覚フィードバック (透明度のみ)
        if (hasMoved) {
          const opacity = Math.max(0.7, 1 - Math.abs(diff) / 300);
          mainImage.style.opacity = opacity.toString();
          mainImage.style.transition = 'none';
        }
      },
      { passive: true }
    );

    mainImage.addEventListener(
      'touchend',
      () => {
        const diff = currentX - startX;
        handleSwipeEnd(diff);
        startX = 0;
        currentX = 0;
        hasMoved = false;
      },
      { passive: true }
    );

    // マウスイベント (PC)
    mainImage.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX;
      currentX = startX;
      hasMoved = false;
      mainImage.style.cursor = 'grabbing';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      currentX = e.clientX;
      const diff = currentX - startX;

      if (Math.abs(diff) > minMoveDistance) {
        hasMoved = true;
      }

      // ドラッグ中の視覚フィードバック (透明度のみ)
      if (hasMoved) {
        const opacity = Math.max(0.7, 1 - Math.abs(diff) / 300);
        mainImage.style.opacity = opacity.toString();
        mainImage.style.transition = 'none';
      }
    });

    document.addEventListener('mouseup', () => {
      if (!isDragging) return;
      isDragging = false;
      const diff = currentX - startX;
      handleSwipeEnd(diff);
      mainImage.style.cursor = 'grab';
      startX = 0;
      currentX = 0;
      hasMoved = false;
    });

    // カーソルスタイル
    mainImage.style.cursor = 'grab';
  }

  function handleSwipeEnd(diff) {
    if (!mainImage) return;

    // 透明度を元に戻すアニメーション
    mainImage.style.transition = 'opacity 0.2s ease';
    mainImage.style.opacity = '1';

    // 移動距離が閾値を超えていたら画像を切り替え
    if (Math.abs(diff) > swipeThreshold && hasMoved) {
      if (diff < 0) {
        // 左スワイプ/ドラッグ (次へ)
        const newIndex = (currentIndex + 1) % images.length;
        setTimeout(() => updateImage(newIndex), 150);
      } else {
        // 右スワイプ/ドラッグ (前へ)
        const newIndex = (currentIndex - 1 + images.length) % images.length;
        setTimeout(() => updateImage(newIndex), 150);
      }
    }
  }
</script>

<style>
  .image-gallery {
    width: 100%;
  }

  .gallery-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2rem;
    margin-bottom: 1rem;
    width: 100%;
    max-width: 1400px;
    margin-left: auto;
    margin-right: auto;
  }

  .side-images {
    display: none; /* スマホ版では非表示 */
  }

  .main-image-container {
    width: 100%;
    max-width: 100%;
    flex: 0 0 auto;
    overflow: hidden;
    border-radius: 8px;
  }

  .main-image {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 8px;
    transition: opacity 0.3s ease;
    user-select: none;
    -webkit-user-drag: none;
  }

  @media (min-width: 768px) {
    .side-images {
      display: grid;
      grid-template-columns: repeat(var(--columns, 1), 120px);
      grid-template-rows: repeat(2, 120px);
      gap: 1rem;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      grid-auto-flow: column;
    }

    .side-img {
      width: 120px;
      height: 120px;
      object-fit: cover;
      opacity: 0.6;
      overflow: hidden;
      border-radius: 50%;
      transition: all 0.3s ease;
      cursor: pointer;
      display: block;
      user-select: none;
      -webkit-user-drag: none;
    }

    .side-img:hover {
      opacity: 0.9;
      transform: scale(1.05);
    }

    :global([data-theme='dark']) .side-img {
      opacity: 0.5;
    }

    :global([data-theme='dark']) .side-img:hover {
      opacity: 0.8;
    }

    .main-image-container {
      flex: 1 1 0;
      width: auto;
      max-width: none;
      min-width: 300px;
    }
  }

  /* ドットナビゲーション */
  .dots-nav {
    display: flex;
    justify-content: center;
    gap: 0.75rem;
    margin-top: 1.25rem;
    max-width: 100%;
    padding: 0.5rem 1rem;
    overflow-x: auto;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .dots-nav::-webkit-scrollbar {
    display: none;
  }

  .dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--color-border);
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 0;
    flex-shrink: 0;
  }

  .dot:hover {
    background: var(--color-primary);
    opacity: 0.7;
  }

  .dot.active {
    background: var(--color-primary);
    transform: scale(1.4);
  }

  @media (max-width: 640px) {
    .main-image-container {
      border-radius: 12px;
    }

    .dots-nav {
      gap: 0.5rem;
      margin-top: 1rem;
      padding: 0.5rem;
      justify-content: flex-start;
    }

    .dot {
      width: 10px;
      height: 10px;
    }

    .dot.active {
      transform: scale(1.3);
    }
  }
</style>
